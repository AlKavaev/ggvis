% Generated by roxygen2 (4.0.0): do not edit by hand
\name{compute_count}
\alias{compute_count}
\title{Count data at each location of a continuous variable}
\usage{
compute_count(x, x_var, w_var = NULL)
}
\arguments{
\item{x}{Dataset-like object to count. Built-in methods for data frames,
grouped data frames and ggvis visualisations.}

\item{x_var,w_var}{Names of x and weight variables.}
}
\value{
A data frame with columns:
 \item{count_}{the number of points}
 \item{x_}{mid-point of bin}
 \item{xmin_}{left boundary of bin}
 \item{xmax_}{right boundary of bin}
 \item{width_}{width of bin}

The width of each "bin" is set to the resolution of the data -- that is, the
smallest difference between two x values.
}
\description{
Count data at each location of a continuous variable
}
\examples{
mtcars \%>\% compute_count(~cyl)

# Weight by car weight
mtcars \%>\% compute_count(~cyl, ~wt)

# If there's one weight value at each x, it effectively just renames columns.
pressure \%>\% compute_count(~temperature, ~pressure)

# It doesn't matter whether you transform inside or outside of a vis
mtcars \%>\% compute_count(~cyl, ~wt) \%>\%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) \%>\%
  layer_rects() \%>\%
  set_dscale("y", "numeric", domain = c(0, 60))
# FIXME: Add support for domainMin and domainMax

mtcars \%>\%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) \%>\%
  compute_count(~cyl, ~wt) \%>\%
  layer_rects() \%>\%
  set_dscale("y", "numeric", domain = c(0, 60))
}
\seealso{
\code{\link{compute_bin}} For counting cases within ranges of
  a continuous variable.

\code{\link{compute_tabulate}} For counting cases at each value
  of a categorical variable.
}

