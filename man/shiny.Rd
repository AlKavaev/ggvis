% Generated by roxygen2 (4.0.0): do not edit by hand
\name{shiny}
\alias{ggvis_output}
\alias{render_controls}
\alias{render_ggvis}
\alias{shiny}
\title{Connect a ggvis graphic to a shiny app.}
\usage{
ggvis_output(plot_id, shiny = TRUE, minify = TRUE)

render_ggvis(gv, session, plot_id, controls_id = NULL, ...)

render_controls(gv, session, controls_id)
}
\arguments{
\item{plot_id}{unique identifier to use for the div containing the ggvis plot.}

\item{shiny}{Should this include headers for Shiny? For dynamic and
interactive plots, this should be TRUE; otherwise FALSE.}

\item{minify}{If \code{TRUE}, use minified version of JS and CSS files. This
can be useful for debugging.}

\item{gv}{A ggvis object, or a reactive expression that returns a ggvis
object.}

\item{session}{A Shiny session object.}

\item{...}{Other arguments passed to \code{as.vega}.}

\item{controls_id}{Unique identifier for controls div.}
}
\description{
It's easiest to learn by example: there are many shiny apps in
\code{demo/apps/} that you can learn from.
}
\details{
There are two required components and one optional component:

\itemize{
  \item Use \code{ggvis_output} in \code{ui.r} to insert a placeholder
  (a div with id) for a ggvis graphic.

  \item Use \code{render_ggvis} in \code{server.r} to insert a ggvis object
  into a shiny app and set up the observers to notify the client side
  whenever the plot data or spec changes.

  \item If the plot uses interactive inputs, use \code{render_controls} to
  insert those controls into the ui.
}
}
\examples{
\dontest{
# Simplest possible app:
shiny::runApp(list(
  ui = bootstrapPage(
    uiOutput("controls"),
    ggvis_output("p")
  ),
  server = function(..., session) {
    mtcars \%>\%
      ggvis(~wt, ~mpg) \%>\%
      layer_points() \%>\%
      layer_smooths(span = input_slider(0, 1)) \%>\%
      render_ggvis(session, "p") \%>\%
      render_controls(session, "controls")
  }
))
}
}

