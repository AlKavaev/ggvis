<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{ggvis basics}
-->

```{r, echo = FALSE, message = FALSE}
library(knitr)
library(ggvis)
opts_chunk$set(comment = "#>", error = TRUE, tidy = FALSE)
```

# ggvis basics

## Introduction

The goal of ggvis is to make it easy to build interactive graphics for exploratory data analysis. ggvis has a similar underlying theory to [ggplot2](http://ggplot2.org) (the grammar of graphics), but it's expressed a little differently, and adds new features to make your plots interactive. ggvis also incorporates reactive programming ideas drawn from [shiny](http://www.rstudio.com/shiny/).

Currently, every interactive ggvis plot must be connected to a running R session. This is great for exploration, because anything you can do in R, you can do in your interactive plot, but not so great for publication. Making it easy to publish ggvis is on our long-term roadmap. For now, if you want to make a ggvis plot broadly available, sign up for [shinyapps](http://www.shinyapps.io/) and publish your ggvis plot there.

The rest of this vignette will introduce you to the major ideas in ggvis, and point you to the other resources where they are explained in more detail.

## `qvis()`

Every ggvis graphic starts with a call to `ggvis()` or `qvis()`. `qvis()` is a __q__uick way of getting our hands dirty with plotting, while `ggvis()` is more verbose but also more explicitl. We'll start with `qvis()` because it lets you start making graphics very quickly.

A basic `qvis()` call has three arguments: a data set, the variable to control x-position and a variable to control y-position.

```{r}
qvis(mtcars, ~wt, ~mpg)
```

(If you're not using RStudio, you'll notice that this plot opens up your web browser. That's because all ggvis graphics are web graphics, and need to be shown in the browser. RStudio includes a built-in browser so it can show you the plots directly.)

If you only supply two arguments, `qvis()` will draw a barchar or histogram depending on whether the x variable is categorical or continuous.

```{r}
qvis(mtcars, ~wt)
```

You can map variables to other aesthietic properties like `fill`, `stroke`, `size` and `shape`:

```{r}
qvis(mtcars, ~wt, ~mpg, stroke = ~vs)
qvis(mtcars, ~wt, ~mpg, fill = ~vs)
qvis(mtcars, ~wt, ~mpg, size = ~vs)
qvis(mtcars, ~wt, ~mpg, shape = ~cyl)
```

If you want to make the points a specified colour or size, you'll need to use `:=` instead of `=`. We'll explain why later on.

```{r}
qvis(mtcars, ~wt, ~mpg, fill := "red", stroke := "black")
qvis(mtcars, ~wt, ~mpg, size := 300)
qvis(mtcars, ~wt, ~mpg, shape := "cross")
```

## Interaction

As well as mapping visual properties to variables, or setting them to specific values, you can also associate them with interactive components. The following example allows you to control the size and opacity of points with two sliders:

```{r}
slider_s <- input_slider(10, 100)
slider_o <- input_slider(0, 1, value = 0.5)

qvis(mtcars, ~wt, ~mpg, size := slider_s, opacity := slider_o)
```

Interactive plots are created using [shiny](http://www.rstudio.com/shiny/), and you can currently only have one running at a time. To finish with a plot, press the stop button in Rstudio, or close the browser window and then press Ctrl + C in R.

You can also use keyboard controls. Press the left and right arrows to control the size of the points in the next example.

```{r}
keys_s <- left_right(10, 300)

ggvis(mtcars, props(x = ~wt, y = ~mpg, size := keys_s)) +
  mark_point()
```

You'll see examples of more complex interaction in the [interactivity](interactivity.html) vignette.

## Layers: marks and branches

The previous examples only show scatterplots and barcharts, but of course you can create many other types of graphic. There are two types of layers that you can add to a plot:

* marks, which are simple drawing primitives like points, lines and rectangles.

* branches, are more complex and combine data transfomation with marks.

There are five basic marks:

* points: `mark_point()`. This is the default when you supply two variables
  to `qvis()`. It has properties `x`, `y`, `shape`, `stroke`, `fill`,
  `strokeOpacity`, `fillOpacity`, and `opacity`.

    ```{r}
    qvis(mtcars, ~wt, ~mpg)
    qvis(mtcars, ~wt, ~mpg, layers = "point")
    ```

* lines: `mark_line()`.

    ```{r}
    df <- data.frame(x = 1:10, y = runif(10))
    qvis(df, ~x, ~y, layers = "line")
    ```

    If you supply a fill, you'll get a polygon

    ```{r}
    t <- seq(0, 2 * pi, length = 100)
    df <- data.frame(x = sin(t), y = cos(t))
    qvis(df, ~x, ~y, fill := "red", layers = "line")
    ```

* filled areas: `mark_area()`. Use properties `y` and `y2` to control the
  extent of the area.

    ```{r}
    df <- data.frame(x = 1:10, y = runif(10))
    qvis(df, ~x, ~y, layers = "area")
    qvis(df, ~x, ~y + 0.1, y2 = ~y - 0.1, layers = "area")
    ```

* rectangles: `mark_rect()`. As well as `x` and `y` properties,
  you also set `x2` and `y2`

    ```{r}
    df <- data.frame(x1 = runif(5), x2 = runif(5), y1 = runif(5), y2 = runif(5))
    qvis(df, ~x1, ~y1, x2 = ~x2, y2 = ~y2, fillOpacity := 0.1, layers = "rect")
    ```

* text: `mark_text()`. `text` (the label), `dx` and `dy` (margin in pixels
  between text and anchor point), `angle` (rotate the text), `font` (font
  name), `fontSize` (size in pixels), `fontWeight` (e.g. bold or normal),
  `fontStyle` (e.g. italic or normal.)

    ```{r}
    df <- data.frame(x = 3:1, y = c(1, 3, 2), label = c("a", "b", "c"))
    qvis(df, ~x, ~y, text := ~label, layers = "text")
    qvis(df, ~x, ~y, text := ~label, layers = "text", fontSize := 50)
    qvis(df, ~x, ~y, text := ~label, layers = "text", angle := 45)
    ```

The two most useful branches are:

* `branch_histogram()` to explore the distribution of a continuous variable.
  This is the default when `qvis()` is not called with a y variable.

  ```{r}
  qvis(mtcars, ~wt)
  qvis(mtcars, ~wt, layers = "histogram")
  ```

  The most important parameter to `branch_histogram()` is the bin width:

  ```{r}
  qvis(mtcars, ~wt, binwidth = 1)
  qvis(mtcars, ~wt, binwidth = 0.1)
  ```

* `branch_smooth()` to overlay a smoother on top of a data cloud:

    ```{r}
    qvis(mtcars, ~wt, ~mpg, layers = "smooth")
    ```

You can learn more about marks and branches in the [marks](marks.html) vignette.

## Multiple layers

There are two ways to display multiple layers on one plot. The first and simplest way is to provide a vector of layer names to `layer`:

```{r}
qvis(mtcars, ~wt, ~mpg, layers = c("smooth", "point"))
```

This is ok for very simple plots, but it's fundamentally limited because you can't use different properties or different parameters on different levels. A more flexible approach is to add branches on to a base plot:

```{r}
qvis(mtcars, ~wt, ~mpg) + branch_smooth()
```

You could use this approach to add two smoothers with varying wiggliness:

```{r}
qvis(mtcars, ~wt, ~mpg) +
  branch_smooth(span = 1, se = FALSE) +
  branch_smooth(span = 0.3, se = FALSE)
```

There's an important difference between `qvis()` and individual branches. `qvis()` does some magic to guess whether an argument is a property or an argument to a transformation. The individual branches don't use this magic, so you need to identify properties by wrapping them in `props()`:

```{r}
qvis(mtcars, ~wt, ~mpg, layers = c("point", "smooth"), stroke := "red")
qvis(mtcars, ~wt, ~mpg, stroke := "red") +
  branch_smooth(props(stroke := "red"))
```

You'll learn more about building up rich hierarchical graphics in the [data hierarchy](data-hierarchy.html) vignette.

## More details

There are also other optional components that you can include:

* `scales`, to control the mapping between data and visual properties.
  These are described in the "properties and scales" vignette.

* `legends` and `axes` to control the appearance of the guides produced by
  the scales.  See the "axes and legends" vignette for more details.
