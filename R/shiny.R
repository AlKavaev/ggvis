#' Connect a ggvis graphic to a shiny app.
#'
#' Embedding ggvis in a shiny app is easy. You need to make a place for it in
#' your \code{ui.r} with \code{ggvisOutput}, and tell your \code{server.r}
#' where to draw it with \code{bind_shiny}. It's easiest to learn by example:
#' there are many shiny apps in \code{demo/apps/} that you can learn from.
#'
#' @section Client-side:
#' In your UI, use \code{ggvisOutput()} in \code{ui.r} to insert an html
#' placeholder for the plot.
#'
#' If you're going to be using interactive controls generated by ggvis,
#' use \code{\link[shiny]{renderUI}()} to add a place holder. By convention,
#' if the id of plot placehold is called "plot", call the controls placeholder
#' "plot_ui".
#'
#' @section Server-side:
#' When you run ggvis plot interactively, it is automatically plotted because
#' it triggers the default print method. In shiny apps, you need to
#' explicitly render the plot to a specific placeholder with
#' \code{bind_shiny}:
#'
#' \code{p \%>\% bind_shiny("plot")}
#'
#' If the plot has controls, and you've reserved space for them in the UI,
#' supply the name of the placeholder as the third argument:
#'
#' \code{p \%>\% bind_shiny("plot", "plot_ui")}
#' @examples
#' \donttest{
#' # Simplest possible app:
#' library(shiny)
#' runApp(list(
#'   ui = bootstrapPage(
#'     ggvisOutput("p"),
#'     uiOutput("p_ui")
#'   ),
#'   server = function(..., session) {
#'     mtcars %>%
#'       ggvis(~wt, ~mpg) %>%
#'       layer_points() %>%
#'       layer_smooths(span = input_slider(0, 1)) %>%
#'       bind_shiny("p", "p_ui")
#'   }
#' ))
#' }
#' @name shiny-ggvis
NULL

#' @rdname shiny-ggvis
#' @param plot_id unique identifier to use for the div containing the ggvis plot.
#' @param shiny Should this include headers for Shiny? For dynamic and
#'   interactive plots, this should be TRUE; otherwise FALSE.
#' @param minify If \code{TRUE}, use minified version of JS and CSS files. This
#'   can be useful for debugging.
#' @export
ggvisOutput <- function(plot_id, shiny = TRUE, minify = TRUE) {
  container <-
    shiny::div(id = paste0(plot_id, "-container"), class = "ggvis-output-container",
      # Div containing the plot
      shiny::div(id = plot_id, class = "ggvis-output"),

      shiny::div(class = "plot-gear-icon",
        ggvisControlGroup(plot_id)
      )
    )


  if (shiny) {
    suppressMessages(
      shiny::addResourcePath("ggvis", system.file("www", package = "ggvis"))
    )

    shiny::tagList(
      shiny::singleton(tags$head(
        html_head(prefix = "ggvis", minify = minify, shiny = TRUE)
      )),
      container
    )

  } else {
    container
  }
}

#' @rdname shiny-ggvis
#' @param vis A ggvis object, or a reactive expression that returns a ggvis
#'   object.
#' @param session A Shiny session object.
#' @param ... Other arguments passed to \code{as.vega}.
#' @export
bind_shiny <- function(vis, plot_id, controls_id = NULL, ...,
                       session = shiny::getDefaultReactiveDomain()) {
  if (is.null(session)) {
    stop("bind_shiny() must be run inside a shiny app.", call. = FALSE)
  }

  if (shiny::is.reactive(vis)) {
    visf <- vis
  } else if (is.ggvis(vis)) {
    visf <- function() vis
  } else {
    stop("bind_shiny requires a ggvis object or a reactive expression that returns a ggvis object",
      call. = FALSE)
  }

  r_spec <- shiny::reactive({
    as.vega(visf(), session = session, dynamic = TRUE, ...)
  })

  observe_spec(r_spec, plot_id, session)
  observe_data(r_spec, plot_id, session)
  exec_connectors(r_spec, plot_id, session)

  if (!is.null(controls_id)) {
    bind_shiny_ui(vis, controls_id, session = session)
  }

  vis
}

# Create an observer for a reactive vega spec
observe_spec <- function(r_spec, id, session) {
  shiny::observe({
    session$sendCustomMessage("ggvis_vega_spec", list(
      plotId = id,
      spec = r_spec()
    ))
  })
}

# Create observers for the data objects attached to a reactive vega spec
observe_data <- function(r_spec, id, session) {
  # A list for keeping track of each data observer
  data_observers <- list()

  shiny::observe({
    # If data_observers list is nonempty, that means there are old observers
    # which need to be suspended before we create new ones. This can happen when
    # the reactive containing the ggvis() call is invalidated.
    for (obs in data_observers) obs$suspend()
    data_observers <<- list()

    data_table <- attr(r_spec(), "data_table")

    # Create observers for each of the data objects
    for (name in ls(data_table, all.names = TRUE)) {
      # The datasets list contains named objects. The names are synthetic IDs
      # that are present in the vega spec. The values can be a variety of things,
      # see the if/else clauses below.
      local({
        # Have to do everything in a local so that these variables are not shared
        # between the different iterations
        data_name <- name

        obs <- shiny::observe({
          data_reactive <- get(data_name, data_table)

          session$sendCustomMessage("ggvis_data", list(
            plotId = id,
            name = data_name,
            value = as.vega(data_reactive(), data_name)
          ))
        })

        # Track this data observer
        data_observers[[length(data_observers) + 1]] <<- obs
      })
    }
  })
}

# Run the connector functions
exec_connectors <- function(r_spec, plot_id, session) {
  connectors <- shiny::isolate(attr(r_spec(), "connectors"))

  lapply(connectors, function(connect) {
    if (!is.null(connect)) {
      connect(session, plot_id)
    }
  })
}

#' @param controls_id Unique identifier for controls div.
#' @rdname shiny-ggvis
#' @export
bind_shiny_ui <- function(vis, controls_id,
                          session = shiny::getDefaultReactiveDomain()) {
  if (is.null(session)) {
    stop("bind_shiny_ui() must be run inside a shiny app.", call. = FALSE)
  }

  if (shiny::is.reactive(vis)) {
    visf <- vis
  } else if (is.ggvis(vis)) {
    visf <- function() vis
  } else {
    stop("bind_shiny_ui requires a ggvis object or a reactive expression that returns a ggvis object",
      call. = FALSE)
  }

  shiny::observe({
    controls <- visf()$controls
    if (empty(controls)) return()

    # Wrap each control in a div, for layout purposes
    divs <- lapply(controls, shiny::div,  class = "ggvis-input-container")
    session$output[[controls_id]] <- shiny::renderUI(shiny::tagList(divs))
  })

  vis
}


#' Create a page with a sidebar
#'
#' This creates a page with a sidebar, where the sidebar moves to the bottom
#' when the width goes below a particular value.
#'
#' @param sidebarPanel The \code{\link{sidebarBottomPanel}} containing input
#'   controls.
#' @param mainPanel The \code{\link{mainTopPanel}} containing the main content.
#' @param shiny_headers Should Shiny headers be embedded in the page? This
#'   should be TRUE for interactive/dynamic pages, FALSE for static pages.
#' @export
#' @examples
#' sidebarBottomPage
sidebarBottomPage <- function(sidebarPanel, mainPanel, shiny_headers = TRUE) {
  content <- shiny::div(
    class = "container-fluid",
    shiny::div(class = "row-fluid",
      mainPanel,
      sidebarPanel
    )
  )

  if (shiny_headers) {
    shiny::bootstrapPage(content)
  } else {
    content
  }
}

#' Create a sidebar panel which moves to the bottom
#'
#' This is to be used with \code{link{sidebarBottomPage}}.
#'
#' @param ... UI elements to include in the sidebar.
#' @export
sidebarBottomPanel <- function(...) {
  shiny::div(class = "span4 sidebar-bottom",
    tags$form(class = "well well-small",
      ...
    )
  )
}


#' Create a main panel which moves to the top
#'
#' This is to be used with \code{link{sidebarBottomPage}}.
#'
#' @param ... UI elements to include in the main panel.
#' @export
mainTopPanel <- function(...) {
  shiny::div(class = "span8 main-top",
    ...
  )
}

#' Generate Shiny tags for ggvis controls
#'
#' Controls for choosing a renderer and downloading an image.
#' @param plot_id Plot ID
#' @export
ggvisControlGroup <- function(plot_id) {
  tags$nav(class = "ggvis-control",
    tags$a(class = "ggvis-dropdown-toggle", title = "Controls", "\u2699"),
    tags$ul(class = "ggvis-dropdown",
      tags$li(
        "Renderer: ",
        tags$a(
          id = paste0(plot_id, "_renderer_svg"),
          class = "ggvis-renderer-button",
          `data-plot-id` = plot_id,
          `data-renderer` = "svg",
          "SVG"
        ),
        " | ",
        tags$a(
          id = paste0(plot_id, "_renderer_canvas"),
          class = "ggvis-renderer-button",
          `data-plot-id` = plot_id,
          `data-renderer` = "canvas",
          "Canvas"
        )
      ),
      tags$li(tags$a(
        id = paste0(plot_id, "_download"),
        class = "ggvis-download",
        `data-plot-id` = plot_id,
        "Download"
      ))
    )
  )
}

#' Create a ggvis control output element in UI
#'
#' This is effectively the same as \code{\link[shiny]{uiOutput}}, except that
#' on the client side it may call some plot resizing functions after new
#' controls are drawn.
#'
#' \code{ggvisControlOutput} is intended to be used with
#' \code{\link{bind_shiny}} on the server side.
#'
#' @param outputId The output variable to read the value from.
#' @param plotId An optional plot ID or vector of plot IDs. The plots will
#'   have their .onControlOutput functions called after the controls are drawn.
#' @examples
#' ggvisControlOutput("plot1")
#' @export
ggvisControlOutput <- function(outputId, plotId = NULL) {
  if (is.null(plotId)) {
    shiny::div(id = outputId, class = "ggvis-control-output")

  } else {
    shiny::div(
      id = outputId,
      class = "ggvis-control-output",
      `data-plot-id` = paste(plotId, collapse = " ")
    )
  }
}
