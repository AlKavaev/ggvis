# Given a gigvis object, return vega scales.
add_scales <- function(node) {
  # Scales that will be filled in by default
  default_scales <- c("x", "y", "stroke", "fill", "opacity")
  # Find scales that are used in the tree
  needed <- needed_scales(node, provided = default_scales)
  by_scale <- split(needed, needed$scale)

  # Get the appropriate scales. If supplied by user, use that; otherwise use
  # vega_scale to automatically generate the scale.
  scales <- lapply(by_scale, function(x) {
    name <- x$scale[[1]]
    gv_scale <- node$scale[[name]]
    vega_scale(gv_scale, name, x$var, x$data, x$var_type)
  })
  unname(scales)
}

# Add scales: ensure that each node - either provided explicitly at that
# level or above, or assigned by the user. 
#
# First figure out which scales are needed (i.e. not found at )

# Build complete set of scales needed. For each property in each mark, need:
# * property name
# * scale name
# * dataset
# * variable type
# (but only if scale isn't already provided)

# Find scales that are used by this node and descendents
needed_scales <- function(node, provided = NULL) {
  provided <- unique(c(provided, names(node$scales)))
  
  # Base case, no children (so a mark)
  if (is.null(node$children)) {
    info <- prop_info(node)
    # Drop items that use a scale but don't have a variable (like constants)
    info <- info[info$var != "", ]

    handled <- is.na(info$scale) | info$scale %in% provided
    return(info[handled, , drop = FALSE])
  }
  
  children <- lapply(node$children, needed_scales, provided = provided)
  do.call("rbind", children)
}

prop_info <- function(node, name = NULL) {
  if (is.null(name)) {
    all <- lapply(names(node$props), prop_info, node = node)
    return(do.call(rbind, all))
  }
  
  prop <- node$props[[name]]

  scale <- prop_scale(prop, default_scale(name))
  type <- prop_type(node$data_obj, prop, processed = TRUE)
  var <- prop_name(prop)
  
  data.frame(
    prop = name, 
    scale = scale, 
    var = var, 
    var_type = type, 
    data = node$data_id,
    stringsAsFactors = FALSE)
}


# Get a vega scale object
# @param scale A gigvis scale object (optional). If NULL, then a vega scale
#   will automatically be generated by examining the data.
# @param scale_name Name of the scale, like 'x' or 'y'.
# @param field Vector of names of fields in the data object, like 'mpg'.
# @param data Name of the data object.
# @param var_type Vector of variable types for each field.
vega_scale <- function(scale = NULL, scale_name, field, data, var_type) {
  var_type <- unique(var_type)
  if (length(var_type) > 1) {
    stop("Scale ", scale_name, " has multiple types of data: ",
      paste0(var_type, collapse = ", "), call. = FALSE)
  }
  if (var_type == "null") return()
  
  if (length(field) != length(data)) {
    stop("field and data must be the same length.")
  }

  scale <- merge_vectors(scale_defaults(scale_name, var_type), scale)

  # These need to be added to all scales not just the ones we've added
  # automatically, so really need to go in a separate step after the
  # default scales have been added
  scale$domain <- list(fields = unname(Map(function(field, data) {
    list(data = data, field = paste0("data.", field))
  }, field, data)))
  
  scale
}


scale_defaults <- function(scale, var_type) {
  scale_type <- if (var_type %in% c("double", "integer")) "linear" else "ordinal"
  
  if (scale == "x") {
    list(
      name   = scale,
      type   = scale_type,
      range  = "width",
      zero   = FALSE,
      nice   = FALSE
    )
  } else if (scale == "y") {
    list(
      name   = scale,
      type   = scale_type,
      range  = "height",
      zero   = FALSE,
      nice   = FALSE
    )
    
  } else if (scale == "stroke") {
    list(
      name   = scale,
      type   = scale_type,
      range  = "category10"
    )
    
  } else if (scale == "fill") {
    list(
      name   = scale,
      type   = scale_type,
      range  = "category10"
    )
    
  } else {
    stop("Unknown scale: ", scale$name)
  }
}
