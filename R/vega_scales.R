# Given a gigvis object, return vega scales.
find_scales <- function(x, nodes, data_table) {
  
  scales <- x$scales
  existing <- names(scales)
  
  # Loop through each node, looking for the scale associated with each property
  needed_scales <- list()
  for (node in nodes) {
    data <- isolate(data_table[[node$pipeline_id]]())
    for (prop_n in names(node$props)) {
      prop <- node$props[[prop_n]]
      scale <- prop_scale(prop, prop_n)
      if (scale %in% existing) next
      
      type <- prop_type(data, prop)
      needed_scales[[scale]] <- c(needed_scales[[scale]], type)
    }
  }
  
  for (scale_n in names(needed_scales)) {
    type <- needed_scales[[scale_n]][[1]]
    scales[[scale_n]] <- scale_defaults(scale_n, type)
  }

  unclass(unname(scales))
}

# Add scales: ensure that each node - either provided explicitly at that
# level or above, or assigned by the user.
#
# First figure out which scales are needed (i.e. not found at )

# Build complete set of scales needed. For each property in each mark, need:
# * property name
# * scale name
# * dataset
# * variable type
# (but only if scale isn't already provided)

# Find scales that are used by this node and descendents
# @param node A gigvis node.
# @param provided Scales that are provided. This is used in two ways: (1) props
#   which use non-provided scales are dropped, and (2) if a provided scale
#   does not specify a type, then the data will be examined to find the
#   type; otherwise the data will not be examined. This is useful for
#   dynamic gigvis plots, where running the pipelines may be deferred for a
#   later stage.
needed_scales <- function(node, provided = NULL) {
  provided <- merge_scales(provided, node$scales)

  # Base case, no children (so a mark)
  if (is.null(node$children)) {
    # Find which scales we know the type of already (because it was provided)
    known_types <- vapply(provided, function(x) x$type %||% "", character(1))
    known_types <- known_types[nzchar(known_types)]

    info <- prop_info(node, known_types = known_types)

    # Drop items that use a scale but don't have a variable (like constants)
    info <- info[info$var != "", ]

    handled <- is.na(info$scale) | info$scale %in% names(provided)
    return(info[handled, , drop = FALSE])
  }

  children <- lapply(node$children, needed_scales, provided = provided)
  do.call("rbind", children)
}

# Get information about a property.
# @param known_types A character vector of scales for which the type is already
#   known. If the type is known, then there's no need to examine data_obj to
#   find the type; if not known, then it will examine data_obj.
prop_info <- function(node, name = NULL, known_types = character(0)) {
  if (is.null(name)) {
    all <- lapply(names(node$props), prop_info, node = node)
    return(do.call(rbind, all))
  }

  prop <- node$props[[name]]

  scale <- prop_scale(prop, default_scale(name))

  # If type is known, use that; otherwise examine the data to find type
  if (name %in% names(known_types)) {
    type <- known_types[[name]]
  } else {
    type <- prop_type(isolate(node$data()), prop, processed = TRUE)
    type <- if (type %in% c("double", "integer")) "linear" else "ordinal"
  }

  var <- prop_name(prop)

  data.frame(
    prop = name,
    scale = scale,
    var = var,
    var_type = type,
    data = node$data_id,
    stringsAsFactors = FALSE)
}


# Get a vega scale object
# @param scale A gigvis scale object (optional). If NULL, then a vega scale
#   will automatically be generated by examining the data.
# @param scale_name Name of the scale, like 'x' or 'y'.
# @param field Vector of names of fields in the data object, like 'mpg'.
# @param data Name of the data object.
# @param var_type Vector of variable types for each field.
vega_scale <- function(scale = NULL, scale_name, field, data, var_type) {
  var_type <- unique(var_type)
  if (length(var_type) > 1) {
    stop("Scale ", scale_name, " has multiple types of data: ",
      paste0(var_type, collapse = ", "), call. = FALSE)
  }
  if (var_type == "null") return()

  if (length(field) != length(data)) {
    stop("field and data must be the same length.")
  }

  scale <- merge_vectors(scale_defaults(scale_name, var_type), scale)

  # These need to be added to all scales not just the ones we've added
  # automatically, so really need to go in a separate step after the
  # default scales have been added
  scale$domain <- list(fields = unname(Map(function(field, data) {
    list(data = data, field = paste0("data.", field))
  }, field, data)))

  scale
}


scale_defaults <- function(scale, var_type) {
  if (scale == "x") {
    list(
      name   = scale,
      type   = var_type,
      range  = "width",
      zero   = FALSE,
      nice   = FALSE
    )
  } else if (scale == "y") {
    list(
      name   = scale,
      type   = var_type,
      range  = "height",
      zero   = FALSE,
      nice   = FALSE
    )

  } else if (scale == "stroke") {
    list(
      name   = scale,
      type   = var_type,
      range  = "category10"
    )

  } else if (scale == "fill") {
    list(
      name   = scale,
      type   = var_type,
      range  = "category10"
    )

  } else {
    stop("Unknown scale: ", scale)
  }
}
